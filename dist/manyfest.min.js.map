{"version":3,"sources":["node_modules/browser-pack/_prelude.js","source/Manyfest-Browser-Shim.js","manyfest.min.js","source/Manyfest-HashTranslation.js","source/Manyfest-LogToConsole.js","source/Manyfest-ObjectAddressGeneration.js","source/Manyfest-ObjectAddressResolver.js","source/Manyfest-SchemaManipulation.js","source/Manyfest.js"],"names":["f","exports","module","define","amd","window","global","self","this","Fable","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","libManyfest","Manyfest","libSimpleLog","constructor","pInfoLog","pErrorLog","logInfo","logError","translationTable","translationCount","Object","keys","addTranslation","pTranslation","forEach","pTranslationSource","removeTranslationHash","pTranslationHash","hasOwnProperty","removeTranslation","clearTranslations","translate","pLogLine","pLogObject","tmpLogLine","console","log","JSON","stringify","generateAddressses","pObject","pBaseAddress","pSchema","tmpBaseAddress","tmpSchema","tmpSchemaObjectEntry","Address","Hash","Name","InSchema","DataType","Default","Array","isArray","tmpObjectProperties","cleanWrapCharacters","pCharacter","pString","startsWith","endsWith","substring","checkAddressExists","pAddress","tmpSeparatorIndex","indexOf","tmpBracketStartIndex","tmpBracketStopIndex","tmpBoxedPropertyName","trim","tmpBoxedPropertyReference","tmpBoxedPropertyNumber","parseInt","isNaN","tmpSubObjectName","tmpNewAddress","getValueAtAddress","pParentAddress","tmpParentAddress","tmpObjectTypeMarkerIndex","tmpObjectPropertyName","tmpArrayProperty","tmpContainerObject","tmpPropertyParentAddress","tmpValue","tmpObjectProperty","tmpObjectPropertyKeys","setValueAtAddress","pValue","resolveAddressMappings","pManyfestSchemaDescriptors","pAddressMapping","tmpManyfestAddresses","tmpHashMapping","pInputAddress","tmpNewDescriptorAddress","tmpOldDescriptorAddress","tmpDescriptor","safeResolveAddressMappings","tmpManyfestSchemaDescriptors","parse","mergeAddressMappings","pManyfestSchemaDescriptorsDestination","pManyfestSchemaDescriptorsSource","tmpSource","tmpNewManyfestSchemaDescriptors","pDescriptorAddress","libHashTranslation","libObjectAddressResolver","libObjectAddressGeneration","libSchemaManipulation","pManifest","pOptions","objectAddressResolver","options","strict","defaultValues","String","Number","Float","Integer","Boolean","Binary","DateTime","Null","scope","undefined","elementAddresses","elementHashes","elementDescriptors","reset","loadManifest","schemaManipulations","objectAddressGeneration","hashTranslations","clone","tmpNewOptions","tmpNewManyfest","getManifest","deserialize","pManifestString","Scope","tmpDescriptionAddresses","Descriptors","addDescriptor","serialize","pDescriptor","push","getDescriptorByHash","pHash","getDescriptor","resolveHashAddress","checkAddressExistsByHash","tmpAddress","tmpInElementHashTable","tmpInTranslationTable","getValueByHash","getDefaultValue","setValueByHash","validate","tmpValidationData","Errors","MissingElements","addValidationError","pErrorMessage","tmpValueExists","Required","tmpElementType","toString","toLowerCase","Date","tmpDataType","populateDefaults","pOverwriteProperties","populateObject","fFilter","tmpObject","tmpOverwriteProperties","tmpFilterFunction"],"mappings":"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","file":"manyfest.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest browser shim loader\n*/\n\n// Load the manyfest module into the browser global automatically.\nvar libManyfest = require('./Manyfest.js');\n\nif (typeof(window) === 'object') window.Manyfest = libManyfest;\n\nmodule.exports = libManyfest;",null,"/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve \n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    removeTranslationHash(pTranslationHash)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslationHash))\n        {\n            delete this.translationTable[pTranslationHash];\n        }\n    }\n\n    // This removes translations.\n    // If passed a string, just removes the single one.\n    // If passed an object, it does all the source keys.\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    translate(pTranslation)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslation))\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object, \n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// generateAddressses\n\t//\n\t// This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t// POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t// quickly.  This is not meant to be used directly to generate schemas, but\n\t// instead as a starting point for scripts or UIs.\n\t//\n\t// This will return a mega set of key:value pairs with all possible schema \n\t// permutations and default values (when not an object) and everything else.\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Resolver\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n*\n* @class ManyfestObjectAddressResolver\n*/\nclass ManyfestObjectAddressResolver\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// When a boxed property is passed in, it should have quotes of some\n\t// kind around it.\n\t//\n\t// For instance:\n\t// \t\tMyValues['Name']\n\t// \t\tMyValues[\"Age\"]\n\t// \t\tMyValues[`Cost`]\n\t//\n\t// This function removes the wrapping quotes.\n\t//\n\t// Please note it *DOES NOT PARSE* template literals, so backticks just\n\t// end up doing the same thing as other quote types.\n\t//\n\t// TODO: Should template literals be processed?  If so what state do they have access to?\n\tcleanWrapCharacters (pCharacter, pString)\n\t{\n\t\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on \n\t// whether the element/property is actually there or not (it returns \n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName].hasOwnProperty(tmpBoxedPropertyReference);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn pObject.hasOwnProperty(pAddress);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpBoxedPropertyName];\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\treturn pObject[pAddress];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);;\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);;\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!pObject.hasOwnProperty('__ERROR'))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolver;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n    // This translates the default address mappings to something different.\n    //\n    // For instance you can pass in manyfest schema descriptor object:\n    // \t{\n\t//\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t//\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t//  }\n    //\n    //\n    // And then an address mapping (basically a Hash->Address map)\n    //  {\n    //    \"a\": \"New.Address.Of.a\",\n    //    \"b\": \"New.Address.Of.b\"  \n    //  }\n    //\n    // NOTE: This mutates the schema object permanently, altering the base hash.\n    //       If there is a collision with an existing address, it can lead to overwrites.\n    // TODO: Discuss what should happen on collisions.\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif (pManyfestSchemaDescriptors[pAddress].hasOwnProperty('Hash'))\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = false;\n\t\t\t\tlet tmpDescriptor = false;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pManyfestSchemaDescriptors.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (tmpHashMapping.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) => \n\t\t\t{\n\t\t\t\tif (!tmpNewManyfestSchemaDescriptors.hasOwnProperty(pDescriptorAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\t\t\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressResolver = require('./Manyfest-ObjectAddressResolver.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest\n{\n\tconstructor(pManifest, pInfoLog, pErrorLog, pOptions)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressResolver = new libObjectAddressResolver(this.logInfo, this.logError);\n\n\t\tthis.options = (\n\t\t\t{\n\t\t\t\tstrict: false,\n\t\t\t\tdefaultValues: \n\t\t\t\t\t{\n\t\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\t\"Null\": null\n\t\t\t\t\t}\n\t\t\t});\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(pManifest) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(pManifest);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Scope'))\n\t\t{\n\t\t\tif (typeof(pManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = pManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(pManifest.Scope)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, pManifest);\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Descriptors'))\n\t\t{\n\t\t\tif (typeof(pManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(pManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], pManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(pManifest.Descriptors)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, pManifest);\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\t// TODO: Should this also serialize the translation table?\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!pDescriptor.hasOwnProperty('Address'))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!this.elementDescriptors.hasOwnProperty(pAddress))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif (pDescriptor.hasOwnProperty('Hash'))\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\t\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressResolver.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = this.elementHashes.hasOwnProperty(pHash);\n\t\tlet tmpInTranslationTable = this.hashTranslations.translationTable.hasOwnProperty(pHash);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && this.elementHashes.hasOwnProperty(this.hashTranslations.translate(pHash)))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table \n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpValue = this.objectAddressResolver.getValueAtAddress(pObject, pAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(pAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressResolver.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (pDescriptor.hasOwnProperty('Default'))\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = (pDescriptor.hasOwnProperty('DataType')) ? pDescriptor.DataType : 'String';\n\t\t\tif (this.options.defaultValues.hasOwnProperty(tmpDataType))\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn pDescriptor.hasOwnProperty('Default');\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;"]}