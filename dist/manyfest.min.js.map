{"version":3,"sources":["node_modules/browser-pack/_prelude.js","source/Manyfest-Browser-Shim.js","manyfest.min.js","source/Manyfest-HashTranslation.js","source/Manyfest-LogToConsole.js","source/Manyfest-ObjectAddressResolver.js","source/Manyfest-SchemaManipulation.js","source/Manyfest.js"],"names":["f","exports","module","define","amd","window","global","self","this","Fable","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","libManyfest","Manyfest","libSimpleLog","constructor","pInfoLog","pErrorLog","logInfo","logError","translationTable","translationCount","Object","keys","addTranslation","pTranslation","forEach","pTranslationSource","removeTranslationHash","pTranslationHash","hasOwnProperty","removeTranslation","clearTranslations","translate","pLogLine","pLogObject","tmpLogLine","console","log","JSON","stringify","cleanWrapCharacters","pCharacter","pString","startsWith","endsWith","substring","checkAddressExists","pObject","pAddress","tmpSeparatorIndex","indexOf","tmpBracketStartIndex","tmpBracketStopIndex","tmpBoxedPropertyName","trim","tmpBoxedPropertyReference","tmpBoxedPropertyNumber","parseInt","Array","isArray","isNaN","tmpSubObjectName","tmpNewAddress","getValueAtAddress","setValueAtAddress","pValue","resolveAddressMappings","pManyfestSchemaDescriptors","pAddressMapping","tmpManyfestAddresses","tmpHashMapping","Hash","pInputAddress","tmpNewDescriptorAddress","tmpOldDescriptorAddress","tmpDescriptor","safeResolveAddressMappings","tmpManyfestSchemaDescriptors","parse","mergeAddressMappings","pManyfestSchemaDescriptorsDestination","pManyfestSchemaDescriptorsSource","tmpSource","tmpNewManyfestSchemaDescriptors","pDescriptorAddress","libObjectAddressResolver","libHashTranslation","libSchemaManipulation","pManifest","pOptions","objectAddressResolver","options","strict","defaultValues","String","Number","Float","Integer","Boolean","Binary","DateTime","Null","scope","undefined","elementAddresses","elementHashes","elementDescriptors","reset","loadManifest","schemaManipulations","hashTranslations","clone","tmpNewOptions","tmpNewManyfest","getManifest","deserialize","pManifestString","Scope","tmpDescriptionAddresses","Descriptors","addDescriptor","serialize","pDescriptor","Address","push","getDescriptorByHash","pHash","getDescriptor","resolveHashAddress","checkAddressExistsByHash","tmpAddress","tmpInElementHashTable","tmpInTranslationTable","getValueByHash","setValueByHash","validate","tmpValidationData","Errors","MissingElements","addValidationError","pErrorMessage","tmpValue","Required","DataType","tmpElementType","toString","toLowerCase","Date","getDefaultValue","Default","tmpDataType","populateDefaults","pOverwriteProperties","populateObject","fFilter","tmpObject","tmpOverwriteProperties","tmpFilterFunction"],"mappings":"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","file":"manyfest.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest browser shim loader\n*/\n\n// Load the manyfest module into the browser global automatically.\nvar libManyfest = require('./Manyfest.js');\n\nif (typeof(window) === 'object') window.Manyfest = libManyfest;\n\nmodule.exports = libManyfest;",null,"/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve \n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    removeTranslationHash(pTranslationHash)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslationHash))\n        {\n            delete this.translationTable[pTranslationHash];\n        }\n    }\n\n    // This removes translations.\n    // If passed a string, just removes the single one.\n    // If passed an object, it does all the source keys.\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    translate(pTranslation)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslation))\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Resolver\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n*\n* @class ManyfestObjectAddressResolver\n*/\nclass ManyfestObjectAddressResolver\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// When a boxed property is passed in, it should have quotes of some\n\t// kind around it.\n\t//\n\t// For instance:\n\t// \t\tMyValues['Name']\n\t// \t\tMyValues[\"Age\"]\n\t// \t\tMyValues[`Cost`]\n\t//\n\t// This function removes the wrapping quotes.\n\t//\n\t// Please note it *DOES NOT PARSE* template literals, so backticks just\n\t// end up doing the same thing as other quote types.\n\t//\n\t// TODO: Should template literals be processed?  If so what state do they have access to?\n\tcleanWrapCharacters (pCharacter, pString)\n\t{\n\t\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on \n\t// whether the element/property is actually there or not (it returns \n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName].hasOwnProperty(tmpBoxedPropertyReference);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn pObject.hasOwnProperty(pAddress);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\treturn pObject[pAddress];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!pObject.hasOwnProperty('__ERROR'))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolver;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n    // This translates the default address mappings to something different.\n    //\n    // For instance you can pass in manyfest schema descriptor object:\n    // \t{\n\t//\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t//\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t//  }\n    //\n    //\n    // And then an address mapping (basically a Hash->Address map)\n    //  {\n    //    \"a\": \"New.Address.Of.a\",\n    //    \"b\": \"New.Address.Of.b\"  \n    //  }\n    //\n    // NOTE: This mutates the schema object permanently, altering the base hash.\n    //       If there is a collision with an existing address, it can lead to overwrites.\n    // TODO: Discuss what should happen on collisions.\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif (pManyfestSchemaDescriptors[pAddress].hasOwnProperty('Hash'))\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = false;\n\t\t\t\tlet tmpDescriptor = false;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pManyfestSchemaDescriptors.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (tmpHashMapping.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) => \n\t\t\t{\n\t\t\t\tif (!tmpNewManyfestSchemaDescriptors.hasOwnProperty(pDescriptorAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\t\t\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libObjectAddressResolver = require('./Manyfest-ObjectAddressResolver.js');\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest\n{\n\tconstructor(pManifest, pInfoLog, pErrorLog, pOptions)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressResolver = new libObjectAddressResolver(this.logInfo, this.logError);\n\n\t\tthis.options = (\n\t\t\t{\n\t\t\t\tstrict: false,\n\t\t\t\tdefaultValues: \n\t\t\t\t\t{\n\t\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\t\"Null\": null\n\t\t\t\t\t}\n\t\t\t});\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(pManifest) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(pManifest);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Scope'))\n\t\t{\n\t\t\tif (typeof(pManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = pManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(pManifest.Scope)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, pManifest);\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Descriptors'))\n\t\t{\n\t\t\tif (typeof(pManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(pManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], pManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(pManifest.Descriptors)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, pManifest);\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\t// TODO: Should this also serialize the translation table?\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!pDescriptor.hasOwnProperty('Address'))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!this.elementDescriptors.hasOwnProperty(pAddress))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif (pDescriptor.hasOwnProperty('Hash'))\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\t\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressResolver.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = this.elementHashes.hasOwnProperty(pHash);\n\t\tlet tmpInTranslationTable = this.hashTranslations.translationTable.hasOwnProperty(pHash);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && this.elementHashes.hasOwnProperty(this.hashTranslations.translate(pHash)))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table \n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\treturn this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressResolver.getValueAtAddress(pObject, pAddress);\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressResolver.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif (typeof(tmpValue) == 'undefined')\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (pDescriptor.hasOwnProperty('Default'))\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = (pDescriptor.hasOwnProperty('DataType')) ? pDescriptor.DataType : 'String';\n\t\t\tif (this.options.defaultValues.hasOwnProperty(tmpDataType))\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn pDescriptor.hasOwnProperty('Default');\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;"]}