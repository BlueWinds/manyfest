{"version":3,"sources":["node_modules/browser-pack/_prelude.js","source/Manyfest-Browser-Shim.js","manyfest.min.js","source/Manyfest-LogToConsole.js","source/Manyfest-ObjectAddressResolver.js","source/Manyfest.js"],"names":["f","exports","module","define","amd","window","global","self","this","Fable","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","libManyfest","Manyfest","pLogLine","pLogObject","tmpLogLine","console","log","JSON","stringify","libSimpleLog","constructor","pInfoLog","pErrorLog","logInfo","logError","cleanWrapCharacters","pCharacter","pString","startsWith","endsWith","substring","checkAddressExists","pObject","pAddress","tmpSeparatorIndex","indexOf","tmpBracketStartIndex","tmpBracketStopIndex","tmpBoxedPropertyName","trim","tmpBoxedPropertyReference","tmpBoxedPropertyNumber","parseInt","Array","isArray","isNaN","hasOwnProperty","tmpSubObjectName","tmpNewAddress","getValueAtAddress","setValueAtAddress","pValue","libObjectAddressResolver","pManifest","pOptions","objectAddressResolver","options","strict","defaultValues","String","Number","Float","Integer","Boolean","Binary","DateTime","Object","Null","scope","undefined","elementAddresses","elementHashes","elementDescriptors","reset","loadManifest","deserialize","pManifestString","parse","Scope","tmpDescriptionAddresses","keys","Descriptors","addDescriptor","serialize","getManifest","pDescriptor","Address","push","Hash","getDescriptorByHash","pHash","getDescriptor","checkAddressExistsByHash","getValueByHash","setValueByHash","validate","tmpValidationData","Errors","MissingElements","addValidationError","pErrorMessage","tmpDescriptor","tmpValue","Required","DataType","tmpElementType","toString","toLowerCase","Date","getDefaultValue","Default","tmpDataType","populateDefaults","pOverwriteProperties","populateObject","fFilter","tmpObject","tmpOverwriteProperties","tmpFilterFunction","forEach"],"mappings":"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","file":"manyfest.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest browser shim loader\n*/\n\n// Load the manyfest module into the browser global automatically.\nvar libManyfest = require('./Manyfest.js');\n\nif (typeof(window) === 'object') window.Manyfest = libManyfest;\n\nmodule.exports = libManyfest;",null,"/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Resolver\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n*\n* @class ManyfestObjectAddressResolver\n*/\nclass ManyfestObjectAddressResolver\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// When a boxed property is passed in, it should have quotes of some\n\t// kind around it.\n\t//\n\t// For instance:\n\t// \t\tMyValues['Name']\n\t// \t\tMyValues[\"Age\"]\n\t// \t\tMyValues[`Cost`]\n\t//\n\t// This function removes the wrapping quotes.\n\t//\n\t// Please note it *DOES NOT PARSE* template literals, so backticks just\n\t// end up doing the same thing as other quote types.\n\t//\n\t// TODO: Should template literals be processed?  If so what state do they have access to?\n\tcleanWrapCharacters (pCharacter, pString)\n\t{\n\t\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on \n\t// whether the element/property is actually there or not (it returns \n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (!typeof(pObject) === 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (!typeof(pAddress) === 'string') return false;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex === -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName].hasOwnProperty(tmpBoxedPropertyReference);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn pObject.hasOwnProperty(pAddress);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (!typeof(pObject) === 'object') return undefined;\n\t\t// Make sure pAddress is a string\n\t\tif (!typeof(pAddress) === 'string') return undefined;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex === -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\treturn pObject[pAddress];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (!typeof(pObject) === 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (!typeof(pAddress) === 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex === -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 0))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!pObject.hasOwnProperty('__ERROR'))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolver;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libObjectAddressResolver = require('./Manyfest-ObjectAddressResolver.js');\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest\n{\n\tconstructor(pManifest, pInfoLog, pErrorLog, pOptions)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressResolver = new libObjectAddressResolver(this.logInfo, this.logError);\n\n\t\tthis.options = (\n\t\t\t{\n\t\t\t\tstrict: false,\n\t\t\t\tdefaultValues: \n\t\t\t\t\t{\n\t\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\t\"Null\": null\n\t\t\t\t\t}\n\t\t\t});\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(pManifest) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(pManifest);\n\t\t}\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Scope'))\n\t\t{\n\t\t\tif (typeof(pManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = pManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(pManifest.Scope)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, pManifest);\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Descriptors'))\n\t\t{\n\t\t\tif (typeof(pManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(pManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], pManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(pManifest.Descriptors)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, pManifest);\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\tlet tmpManifest = (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!pDescriptor.hasOwnProperty('Address'))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!this.elementDescriptors.hasOwnProperty(pAddress))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\t// TODO: Check if this is a good idea or not.\n\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here.\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif (pDescriptor.hasOwnProperty('Hash'))\n\t\t\t{\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\t\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\tif (this.elementHashes.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn this.getDescriptor(this.elementHashes[pHash]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error in getDescriptorByHash; the Hash ${pHash} doesn't exist in the schema.`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\tif (this.elementHashes.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn this.checkAddressExists(pObject, this.elementHashes[pHash]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error in checkAddressExistsByHash; the Hash ${pHash} doesn't exist in the schema.`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressResolver.checkAddressExists(pObject, pAddress);\n\t}\n\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tif (this.elementHashes.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn this.getValueAtAddress(pObject, this.elementHashes[pHash]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error in getValueByHash; the Hash ${pHash} doesn't exist in the schema.`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressResolver.getValueAtAddress(pObject, pAddress);\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\tif (this.elementHashes.hasOwnProperty(pHash))\n\t\t{\n\t\t\treturn this.setValueAtAddress(pObject, this.elementHashes[pHash], pValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error in setValueByHash; the Hash ${pHash} doesn't exist in the schema.  Value ${pValue} will not be written!`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressResolver.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif (typeof(tmpValue) == 'undefined')\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (pDescriptor.hasOwnProperty('Default'))\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = (pDescriptor.hasOwnProperty('DataType')) ? pDescriptor.DataType : 'String';\n\t\t\tif (this.options.defaultValues.hasOwnProperty(tmpDataType))\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn pDescriptor.hasOwnProperty('Default');\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;"]}